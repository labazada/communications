- comprobar de alguna manera que ML_SMCAlgorithm recibe como estimador de canal un KalmanEstimator
- optimizar las Particles para que en el constructor copia solo se copien las matrices ocupadas
- en ParticleWithCh... comprobar que la matriz pasada en los metodos Set tiene el tamaño adecuado
- mas comprobaciones en los métodos de Particle y derivados
- pasar todo lo que sea posible por referencia (los preamble a los algoritmos)
- variable endResamplingTime en SMCAlgorithm::Resampling
- pasar las observaciones por referencia
- en ML_SMCAlgorithm
  - nObservations ya no vale para nada
  - mFirstColumns pilla una columna de mas
- ML_UnknownChannelOrderSMCAlgorithm
  - sustituir _startDetectionSymbolVector-_startDetectionObservation+iObservationToBeProcessed por otra cosa
- quitar nParticlesPerChannelOrder de UnknownChannelOrderSMCAlgorithm
- eliminar _iFirstObsevation de UnknownChannelOrderAlgorithm
- añadir el atributo _antennasChannelOrder a MIMOChannel (y el método get correspondiente)
- reestructurar las clases relacionadas con el ruido (que no se cree la matriz de ruido en la clase base)
- definir preambulo en algun lugar más alto de la jerarquía
- eliminar "_d" de MultipleChannelEstimatorsPerParticleSMCAlgorithm y sus clases derivadas
- para calcular la overallPe y mse, hacer la división al final
- memcpy para hacer copias de arrays (en el remuestreo por ejemplo)
- que la función SetEstimatorIndex de SMCAlgorithm no sea pública
- las variables _cost y _detectedSequence de ViterbiPath no sean públicas (amigas o algo así)
- que un ChannelMatrixEstimator reciba la memoria en el constructor
- que los algoritmos en lugar de recibir K reciban endDetection o algo así
- eliminar de ViterbiAlgorithm lo de "	const StillMemoryMIMOChannel &channel = dynamic_cast<const StillMemoryMIMOChannel &> (_channel);"
- en ViterbiAlgorith, que BestState() sea private
- KalmanEstimator en NextMatrix: que use la media predictiva no la filtrada (revisar)
- las variables _c y _d subirlas en la jerarquía
- eliminar si es posible la distinción entre Run y Run con secuencia de entrenamiento
- proceso AR: multiplicar por la varianza
- el constructor de SMCAlgorithm no debería recibir smoothingLag
- KnownSymbolsKalmanBasedChannelEstimatorAlgorithm no tiene que recibir necesariamente un estimador de Kalman => cambiarle el nombre KnownSymbolsChannelEstimatorAlgorithm
- UnknownChannelOrderAlgorithm: hacer ProcessTrainingSequence protected
- USIS2SISAlgorithm
  - MakeTransition(_weightedChannelOrderAPPs) debería devolver el orden al que se pasa (no simplemente un bool) y ese debería usarse dentro del if
- LinearFilterBasedSMCAlgorithm
  - cuando se sustraiga la contribución de los símbolos anteriores automáticamente se elija el detector pequeño y lo contrario
- delete observationVectorLength from KalmanFilter constructor
- normalizar códigos
- cálculo de la probabilidad de error
- canales buenos
- como genero SNR
